import time
import threading

class LockerManager:
    def __init__(self, mqtt_manager=None, api_manager=None):
        # √âtat local des casiers pour l'affichage (True = libre, False = r√©serv√©/occup√©)
        self.lockers_display = [False, True]  # Valeurs par d√©faut
        
        # Codes de d√©verrouillage fallback
        self.fallback_codes = {
            0: "1234",  # Casier 1
            1: "5678"   # Casier 2
        }
        
        # Gestionnaires
        self.mqtt_manager = mqtt_manager
        self.api_manager = api_manager
        
        # Timers pour auto-fermeture
        self.timers = {}
        
        # Callback pour mise √† jour de l'interface
        self.on_status_change_callback = None
        
        print("üé≠ LockerManager initialis√©")
        
        # Synchroniser avec l'API au d√©marrage
        if self.api_manager:
            self.sync_with_api()
    
    def set_status_change_callback(self, callback):
        """D√©finit le callback pour les changements d'√©tat"""
        self.on_status_change_callback = callback
    
    def get_locker_status(self, locker_id):
        """Retourne l'√©tat d'affichage d'un casier (True = libre, False = r√©serv√©/occup√©)"""
        if 0 <= locker_id < len(self.lockers_display):
            return self.lockers_display[locker_id]
        return False
    
    def get_locker_detailed_status(self, locker_id):
        """Retourne le statut d√©taill√© d'un casier (libre/r√©serv√©/occup√©)"""
        if self.api_manager:
            return self.api_manager.get_casier_status(locker_id)
        return 'libre'
    
    def reserve_locker(self, locker_id):
        """R√©serve un casier (le marque comme r√©serv√©)"""
        if 0 <= locker_id < len(self.lockers_display) and self.lockers_display[locker_id]:
            # Mettre √† jour localement
            self.lockers_display[locker_id] = False
            print(f"üîí Casier {locker_id + 1} r√©serv√© localement")
            
            # Mettre √† jour via l'API
            if self.api_manager:
                success = self.api_manager.reserve_locker(locker_id)
                if success:
                    print(f"‚úÖ R√©servation API confirm√©e pour casier {locker_id + 1}")
                else:
                    print(f"‚ö†Ô∏è √âchec r√©servation API pour casier {locker_id + 1}")
                    # Revenir en arri√®re si l'API √©choue
                    self.lockers_display[locker_id] = True
                    return False
            
            self._notify_status_change()
            return True
        return False
    
    def release_locker(self, locker_id):
        """Lib√®re un casier (le marque comme libre)"""
        if 0 <= locker_id < len(self.lockers_display):
            # Mettre √† jour localement
            self.lockers_display[locker_id] = True
            print(f"üîì Casier {locker_id + 1} lib√©r√© localement")
            
            # Mettre √† jour via l'API
            if self.api_manager:
                success = self.api_manager.release_locker(locker_id)
                if success:
                    print(f"‚úÖ Lib√©ration API confirm√©e pour casier {locker_id + 1}")
                else:
                    print(f"‚ö†Ô∏è √âchec lib√©ration API pour casier {locker_id + 1}")
            
            self._notify_status_change()
            return True
        return False
    
    def occupy_locker(self, locker_id):
        """Marque un casier comme occup√© (transition r√©serv√© -> occup√©)"""
        if 0 <= locker_id < len(self.lockers_display):
            print(f"üè† Casier {locker_id + 1} marqu√© comme occup√©")
            
            # Mettre √† jour via l'API
            if self.api_manager:
                success = self.api_manager.occupy_locker(locker_id)
                if success:
                    print(f"‚úÖ Occupation API confirm√©e pour casier {locker_id + 1}")
                    return True
                else:
                    print(f"‚ö†Ô∏è √âchec occupation API pour casier {locker_id + 1}")
                    return False
            
            return True
        return False
    
    def verify_code(self, locker_id, code):
        """V√©rifie le code et d√©clenche l'ouverture physique si correct"""
        if 0 <= locker_id < len(self.lockers_display):
            # V√©rifier le statut d√©taill√© du casier
            detailed_status = self.get_locker_detailed_status(locker_id)
            
            if detailed_status == 'reserve':
                # Casier r√©serv√© : v√©rifier le code via l'API
                if self.api_manager:
                    is_valid = self.api_manager.verify_user_code(locker_id, code)
                else:
                    # Fallback sur les codes locaux
                    is_valid = self.fallback_codes.get(locker_id) == code
                    print(f"‚ö†Ô∏è Utilisation du code fallback pour casier {locker_id + 1}")
            elif detailed_status == 'occupe':
                # Casier occup√© : utiliser les codes fallback ou API si disponible
                if self.api_manager:
                    is_valid = self.api_manager.verify_user_code(locker_id, code)
                    if not is_valid:
                        # Essayer aussi le code fallback pour la lib√©ration
                        is_valid = self.fallback_codes.get(locker_id) == code
                else:
                    is_valid = self.fallback_codes.get(locker_id) == code
            else:
                # Casier libre : ne devrait pas arriver
                print(f"‚ö†Ô∏è Tentative d'ouverture d'un casier libre {locker_id + 1}")
                return False
            
            if is_valid:
                print(f"‚úÖ Code correct pour casier {locker_id + 1}")
                
                # Logger l'action
                if self.api_manager:
                    self.api_manager.log_action(locker_id, "unlock", {"code_used": True, "status": detailed_status})
                
                # D√©clencher l'ouverture physique
                self.trigger_physical_opening(locker_id)
                
                # G√©rer la transition d'√©tat selon le statut actuel
                if detailed_status == 'reserve':
                    # R√©serv√© -> Occup√©
                    self.occupy_locker(locker_id)
                elif detailed_status == 'occupe':
                    # Occup√© -> Libre (lib√©ration)
                    self.release_locker(locker_id)
                
            else:
                print(f"‚ùå Code incorrect pour casier {locker_id + 1}")
                
                # Logger la tentative √©chou√©e
                if self.api_manager:
                    self.api_manager.log_action(locker_id, "unlock_failed", {"code_used": False, "status": detailed_status})
            
            return is_valid
        return False

    def trigger_physical_opening(self, locker_id):
        """D√©clenche l'ouverture physique du casier avec timer de 20 secondes"""
        print(f"üîì D√©clenchement ouverture physique casier {locker_id + 1}")
        
        # Annuler le timer pr√©c√©dent s'il existe
        if locker_id in self.timers:
            self.timers[locker_id].cancel()
        
        # Envoyer commande d'ouverture via MQTT
        if self.mqtt_manager:
            self.mqtt_manager.open_locker(locker_id)
        
        # Programmer la fermeture automatique apr√®s 20 secondes
        def auto_close():
            print(f"‚è∞ Auto-fermeture casier {locker_id + 1} apr√®s 20 secondes")
            if self.mqtt_manager:
                self.mqtt_manager.close_locker(locker_id)
        
        self.timers[locker_id] = threading.Timer(20.0, auto_close)
        self.timers[locker_id].start()
        
        print(f"‚è±Ô∏è Timer de 20 secondes activ√© pour casier {locker_id + 1}")
    
    def _notify_status_change(self):
        """Notifie l'interface d'un changement d'√©tat"""
        if self.on_status_change_callback:
            self.on_status_change_callback()
    
    def cleanup(self):
        """Nettoie les timers actifs"""
        for timer in self.timers.values():
            if timer.is_alive():
                timer.cancel()
        self.timers.clear()
        print("üßπ Timers nettoy√©s")

    def sync_with_api(self):
        """Synchronise l'√©tat avec l'API"""
        if self.api_manager:
            try:
                print("üîÑ Synchronisation avec l'API...")
                api_status = self.api_manager.get_lockers_status()
                if api_status:
                    # Mettre √† jour l'√©tat local avec les donn√©es de l'API
                    self.lockers_display = api_status
                    self._notify_status_change()
                    print(f"‚úÖ √âtat synchronis√© avec l'API: {api_status}")
                    return True
                else:
                    print("‚ö†Ô∏è Pas de donn√©es API, conservation de l'√©tat local")
                    return False
            except Exception as e:
                print(f"‚ùå Erreur synchronisation API: {e}")
                return False
        return False
    
    def update_from_api(self, locker_id, status):
        """Met √† jour l'√©tat d'un casier depuis l'API"""
        if 0 <= locker_id < len(self.lockers_display):
            self.lockers_display[locker_id] = status
            self._notify_status_change()
            print(f"üîÑ API: Casier {locker_id + 1} -> {'LIBRE' if status else 'R√âSERV√â/OCCUP√â'}")
    
    def force_sync(self):
        """Force une synchronisation imm√©diate avec l'API"""
        return self.sync_with_api()
